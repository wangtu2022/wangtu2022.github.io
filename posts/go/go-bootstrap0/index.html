<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？">
<meta itemprop="description" content="大家好，我是煎鱼。
自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：
import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world.&#34;) } 这段程序的输出结果为 hello world.，就是这么的简单又直接。但这时候又不禁思考了起来，这个 hello world. 是怎么输出来，经历了什么过程。
真是非常的好奇，今天我们就一起来探一探 Go 程序的启动流程。 其中涉及到 Go Runtime 的调度器启动，g0，m0 又是什么？
车门焊死，正式开始吸鱼之路。"><meta itemprop="datePublished" content="2021-06-17T12:42:42+08:00" />
<meta itemprop="dateModified" content="2021-06-17T12:42:42+08:00" />
<meta itemprop="wordCount" content="645">
<meta itemprop="keywords" content="go," /><meta property="og:title" content="详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？" />
<meta property="og:description" content="大家好，我是煎鱼。
自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：
import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world.&#34;) } 这段程序的输出结果为 hello world.，就是这么的简单又直接。但这时候又不禁思考了起来，这个 hello world. 是怎么输出来，经历了什么过程。
真是非常的好奇，今天我们就一起来探一探 Go 程序的启动流程。 其中涉及到 Go Runtime 的调度器启动，g0，m0 又是什么？
车门焊死，正式开始吸鱼之路。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangtu2022.github.io/posts/go/go-bootstrap0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-17T12:42:42+08:00" />
<meta property="article:modified_time" content="2021-06-17T12:42:42+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？"/>
<meta name="twitter:description" content="大家好，我是煎鱼。
自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：
import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world.&#34;) } 这段程序的输出结果为 hello world.，就是这么的简单又直接。但这时候又不禁思考了起来，这个 hello world. 是怎么输出来，经历了什么过程。
真是非常的好奇，今天我们就一起来探一探 Go 程序的启动流程。 其中涉及到 Go Runtime 的调度器启动，g0，m0 又是什么？
车门焊死，正式开始吸鱼之路。"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</title>
	<link rel="stylesheet" href="https://wangtu2022.github.io/css/style.min.d3141168199607bf3a517216ce3c263814eecdbc8fca72a9a88700799a838219.css" integrity="sha256-0xQRaBmWB786UXIWzjwmOBTuzbyPynKpqIcAeZqDghk=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
	<link rel="stylesheet" href="https://wangtu2022.github.io/css/styles.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://wangtu2022.github.io/">煎鱼</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://wangtu2022.github.io/posts/">文章</a>
				<a href="https://wangtu2022.github.io/tags/">标签</a>
				<a href="https://wangtu2022.github.io/about/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/eddycjy" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://wangtu2022.github.io/posts/">文章</a></li>
			<li><a href="https://wangtu2022.github.io/tags/">标签</a></li>
			<li><a href="https://wangtu2022.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jun 17, 2021</span></div>
				<h1>详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</h1>
			</header>
			<div class="content">
				<p>大家好，我是煎鱼。</p>
<p>自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：</p>
<pre tabindex="0"><code>import &#34;fmt&#34;

func main() {
	fmt.Println(&#34;hello world.&#34;)
}
</code></pre><p>这段程序的输出结果为 <code>hello world.</code>，就是这么的简单又直接。但这时候又不禁思考了起来，这个 <code>hello world.</code> 是怎么输出来，经历了什么过程。</p>
<p>真是非常的好奇，今天我们就一起来探一探 Go 程序的启动流程。
其中涉及到 Go Runtime 的调度器启动，g0，m0 又是什么？</p>
<p>车门焊死，正式开始吸鱼之路。</p>
<h2 id="go-引导阶段">Go 引导阶段<a href="#go-引导阶段" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="查找入口">查找入口<a href="#查找入口" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>首先编译上文提到的示例程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">&#34;-ldflags=-compressdwarf=false&#34;</span> go build 
</span></span></code></pre></div><p>在命令中指定了 GOFLAGS 参数，这是因为在 Go1.11 起，为了减少二进制文件大小，调试信息会被压缩。导致在 MacOS 上使用 gdb 时无法理解压缩的 DWARF 的含义是什么（而我恰恰就是用的 MacOS）。</p>
<p>因此需要在本次调试中将其关闭，再使用 gdb 进行调试，以此达到观察的目的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ gdb awesomeProject 
</span></span><span class="line"><span class="cl"><span class="o">(</span>gdb<span class="o">)</span> info files
</span></span><span class="line"><span class="cl">Symbols from <span class="s2">&#34;/Users/eddycjy/go-application/awesomeProject/awesomeProject&#34;</span>.
</span></span><span class="line"><span class="cl">Local <span class="nb">exec</span> file:
</span></span><span class="line"><span class="cl">	<span class="sb">`</span>/Users/eddycjy/go-application/awesomeProject/awesomeProject<span class="err">&#39;</span>, file <span class="nb">type</span> mach-o-x86-64.
</span></span><span class="line"><span class="cl">	Entry point: 0x1063c80
</span></span><span class="line"><span class="cl">	0x0000000001001000 - 0x00000000010a6aca is .text
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl"><span class="o">(</span>gdb<span class="o">)</span> b *0x1063c80
</span></span><span class="line"><span class="cl">Breakpoint <span class="m">1</span> at 0x1063c80: file /usr/local/Cellar/go/1.15/libexec/src/runtime/rt0_darwin_amd64.s, line 8.
</span></span></code></pre></div><p>通过 Entry point 的调试，可看到真正的程序入口在 runtime 包中，不同的计算机架构指向不同。例如：</p>
<ul>
<li>MacOS 在 <code>src/runtime/rt0_darwin_amd64.s</code>。</li>
<li>Linux 在 <code>src/runtime/rt0_linux_amd64.s</code>。</li>
</ul>
<p>其最终指向了 rt0_darwin_amd64.s 文件，这个文件名称非常的直观：</p>
<pre tabindex="0"><code>Breakpoint 1 at 0x1063c80: file /usr/local/Cellar/go/1.15/libexec/src/runtime/rt0_darwin_amd64.s, line 8.
</code></pre><p>rt0 代表 runtime0 的缩写，指代运行时的创世，超级奶爸：</p>
<ul>
<li>darwin 代表目标操作系统（GOOS）。</li>
<li>amd64 代表目标操作系统架构（GOHOSTARCH）。</li>
</ul>
<p>同时 Go 语言还支持更多的目标系统架构，例如：AMD64、AMR、MIPS、WASM 等：</p>
<p><img src="https://image.eddycjy.com/981720dfbce750bec26fc394e97d9ff7.jpg" alt="源码目录"></p>
<p>若有兴趣可到 <code>src/runtime</code> 目录下进一步查看，这里就不一一介绍了。</p>
<h3 id="入口方法">入口方法<a href="#入口方法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在 rt0_linux_amd64.s 文件中，可发现 <code>_rt0_amd64_darwin</code> JMP 跳转到了 <code>_rt0_amd64</code> 方法：</p>
<pre tabindex="0"><code>TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB)
...
</code></pre><p>紧接着又跳转到 <code>runtime·rt0_go</code> 方法：</p>
<pre tabindex="0"><code>TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB)
</code></pre><p>该方法将程序输入的 argc 和 argv 从内存移动到寄存器中。</p>
<p>栈指针（SP）的前两个值分别是 argc 和 argv，其对应参数的数量和具体各参数的值。</p>
<h3 id="开启主线">开启主线<a href="#开启主线" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>程序参数准备就绪后，正式初始化的方法落在 <code>runtime·rt0_go</code> 方法中：</p>
<pre tabindex="0"><code>TEXT runtime·rt0_go(SB),NOSPLIT,$0
	...
	CALL	runtime·check(SB)
	MOVL	16(SP), AX		// copy argc
	MOVL	AX, 0(SP)
	MOVQ	24(SP), AX		// copy argv
	MOVQ	AX, 8(SP)
	CALL	runtime·args(SB)
	CALL	runtime·osinit(SB)
	CALL	runtime·schedinit(SB)

	// create a new goroutine to start program
	MOVQ	$runtime·mainPC(SB), AX		// entry
	PUSHQ	AX
	PUSHQ	$0			// arg size
	CALL	runtime·newproc(SB)
	POPQ	AX
	POPQ	AX

	// start this M
	CALL	runtime·mstart(SB)
	...
</code></pre><ul>
<li>runtime.check：运行时类型检查，主要是校验编译器的翻译工作是否正确，是否有 “坑”。基本代码均为检查 <code>int8</code> 在 <code>unsafe.Sizeof</code> 方法下是否等于 1 这类动作。</li>
<li>runtime.args：系统参数传递，主要是将系统参数转换传递给程序使用。</li>
<li>runtime.osinit：系统基本参数设置，主要是获取 CPU 核心数和内存物理页大小。</li>
<li>runtime.schedinit：进行各种运行时组件的初始化，包含调度器、内存分配器、堆、栈、GC 等一大堆初始化工作。会进行 p 的初始化，并将 m0 和某一个 p 进行绑定。</li>
<li>runtime.main：主要工作是运行 main goroutine，虽然在<code>runtime·rt0_go</code> 中指向的是<code>$runtime·mainPC</code>，但实质指向的是 <code>runtime.main</code>。</li>
<li>runtime.newproc：创建一个新的 goroutine，且绑定 <code>runtime.main</code> 方法（也就是应用程序中的入口 main 方法）。并将其放入 m0 绑定的p的本地队列中去，以便后续调度。</li>
<li>runtime.mstart：启动 m，调度器开始进行循环调度。</li>
</ul>
<p>在 <code>runtime·rt0_go</code> 方法中，其主要是完成各类运行时的检查，系统参数设置和获取，并进行大量的 Go 基础组件初始化。</p>
<p>初始化完毕后进行主协程（main goroutine）的运行，并放入等待队列（GMP 模型），最后调度器开始进行循环调度。</p>
<h3 id="小结">小结<a href="#小结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>根据上述源码剖析，可以得出如下 Go 应用程序引导的流程图：</p>
<p><img src="https://image.eddycjy.com/057c1ccb06c16e8c5f38ff5800e3fa63.jpg" alt="Go 程序引导过程"></p>
<p>在 Go 语言中，实际的运行入口并不是用户日常所写的 <code>main func</code>，更不是 <code>runtime.main</code> 方法，而是从 <code>rt0_*_amd64.s</code> 开始，最终再一路 JMP 到 <code>runtime·rt0_go</code> 里去，再在该方法里完成一系列 Go 自身所需要完成的绝大部分初始化动作。</p>
<p>其中整体包括：</p>
<ul>
<li>运行时类型检查、系统参数传递、CPU 核数获取及设置、运行时组件的初始化（调度器、内存分配器、堆、栈、GC 等）。</li>
<li>运行 main goroutine。</li>
<li>运行相应的 GMP 等大量缺省行为。</li>
<li>涉及到调度器相关的大量知识。</li>
</ul>
<p>后续将会继续剖析将进一步剖析 <code>runtime·rt0_go</code> 里的爱与恨，尤其像是 <code>runtime.main</code>、<code>runtime.schedinit</code> 等调度方法，都有非常大的学习价值，有兴趣的小伙伴可以持续关注。</p>
<h2 id="go-调度器初始化">Go 调度器初始化<a href="#go-调度器初始化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>知道了 Go 程序是怎么引导起来的之后，我们需要了解 Go Runtime 中调度器是怎么流转的。</p>
<h3 id="runtimemstart">runtime.mstart<a href="#runtimemstart" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>这里主要关注 <code>runtime.mstart</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取 g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 确定栈边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">osStack</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">osStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">size</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">size</span> <span class="p">=</span> <span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">size</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">size</span> <span class="o">+</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 启动 m，进行调度器循环调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">mstart1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 退出线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nf">mStackIsSystemAllocated</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">osStack</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>调用 <code>getg</code> 方法获取 GMP 模型中的 g，此处获取的是 g0。</li>
<li>通过检查 g 的执行栈 <code>_g_.stack</code> 的边界（堆栈的边界正好是 lo, hi）来确定是否为系统栈。若是，则根据系统栈初始化 g 执行栈的边界。</li>
<li>调用 <code>mstart1</code> 方法启动系统线程 m，进行调度器循环调度。</li>
<li>调用 <code>mexit</code> 方法退出系统线程 m。</li>
</ul>
<h3 id="runtimemstart1">runtime.mstart1<a href="#runtimemstart1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>这么看来其实质逻辑在 <code>mstart1</code> 方法，我们继续往下剖析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取 g，并判断是否为 g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad runtime·mstart&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 初始化 m 并记录调用方 pc、sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nf">asminit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">minit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置信号 handler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mstartm0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 运行启动函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">fn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">schedule</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>调用 <code>getg</code> 方法获取 g。并且通过前面绑定的 <code>_g_.m.g0</code> 判断所获取的 g 是否 g0。若不是，则直接抛出致命错误。因为调度器仅在 g0 上运行。</li>
<li>调用 <code>minit</code> 方法初始化 m，并记录调用方的 PC、SP，便于后续 schedule 阶段时的复用。</li>
<li>若确定当前的 g 所绑定的 m 是 m0，则调用 <code>mstartm0</code> 方法，设置信号 handler。该动作必须在 <code>minit</code> 方法之后，这样 <code>minit</code> 方法可以提前准备好线程，以便能够处理信号。</li>
<li>若当前 g 所绑定的 m 有启动函数，则运行。否则跳过。</li>
<li>若当前 g 所绑定的 m 不是 m0，则需要调用 <code>acquirep</code> 方法获取并绑定 p，也就是 m 与 p 绑定。</li>
<li>调用 <code>schedule</code> 方法进行正式调度。</li>
</ul>
<p>忙活了一大圈，终于进入到开题的主菜了，原来潜伏的很深的 <code>schedule</code> 方法才是真正做调度的方法，其他都是前置处理和准备数据。</p>
<p>由于篇幅问题，<code>schedule</code> 方法会放到下篇再继续剖析，我们先聚焦本篇的一些细节点。</p>
<h2 id="问题深剖">问题深剖<a href="#问题深剖" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>不过到这里篇幅也已经比较长了，积累了不少问题。我们针对在 Runtime 中出镜率最高的两个元素进行剖析：</p>
<ol>
<li><code>m0</code> 是什么，作用是？</li>
<li><code>g0</code> 是什么，作用是？</li>
</ol>
<h3 id="m0">m0<a href="#m0" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>m0 是 Go Runtime 所创建的第一个系统线程，一个 Go 进程只有一个 m0，也叫主线程。</p>
<p>从多个方面来看：</p>
<ul>
<li>数据结构：m0 和其他创建的 m 没有任何区别。</li>
<li>创建过程：m0 是进程在启动时应该汇编直接复制给 m0 的，其他后续的 m 则都是 Go Runtime 内自行创建的。</li>
<li>变量声明：m0 和常规 m 一样，m0 的定义就是 <code>var m0 m</code>，没什么特别之处。</li>
</ul>
<h3 id="g0">g0<a href="#g0" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>g 一般分为三种，分别是：</p>
<ul>
<li>执行用户任务的叫做 g。</li>
<li>执行 <code>runtime.main</code> 的 main goroutine。</li>
<li>执行调度任务的叫 g0。。</li>
</ul>
<p>g0 比较特殊，每一个 m 都只有一个 g0（仅此只有一个 g0），且每个 m 都只会绑定一个 g0。在 g0 的赋值上也是通过汇编赋值的，其余后续所创建的都是常规的 g。</p>
<p>从多个方面来看：</p>
<ul>
<li>数据结构：g0 和其他创建的 g 在数据结构上是一样的，但是存在栈的差别。在 g0 上的栈分配的是系统栈，在 Linux 上栈大小默认固定 8MB，不能扩缩容。 而常规的 g 起始只有 2KB，可扩容。</li>
<li>运行状态：g0 和常规的 g 不一样，没有那么多种运行状态，也不会被调度程序抢占，调度本身就是在 g0 上运行的。</li>
<li>变量声明：g0 和常规 g，g0 的定义就是 <code>var g0 g</code>，没什么特别之处。</li>
</ul>
<h3 id="小结-1">小结<a href="#小结-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在本章节中我们讲解了 Go 调度器初始化的一个过程，分别涉及：</p>
<ul>
<li>runtime.mstart。</li>
<li>runtime.mstart1。</li>
</ul>
<p>基于此也了解到了在调度器初始化过程中，需要准备什么，初始化什么。另外针对调度过程中最常提到的 m0、g0 的概念我们进行了梳理和说明。</p>
<h2 id="总结">总结<a href="#总结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在今天这篇文章中，我们详细的介绍了 Go 语言的引导启动过程中的所有流程和初始化动作。</p>
<p>同时针对调度器的初始化进行了初步分析，详细介绍了 m0、g0 的用途和区别。
在下一篇文章中我们将进一步对真正调度的 <code>schedule</code> 方法进行详解，这块也是个硬骨头了。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://wangtu2022.github.io/tags/go">go</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>645 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-06-17 12:42 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://wangtu2022.github.io/posts/go/go-empty-struct/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>用 Go struct 不能犯的一个低级错误！</span>
			</a>
			<a class="prev-post" href="https://wangtu2022.github.io/posts/go/goroutine-leak/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>跟面试官聊 Goroutine 泄露的 6 种方法，真刺激！</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://wangtu2022.github.io/">煎鱼</a> &#183; <a href="http://www.beian.miit.gov.cn/">粤ICP备19076352号</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://wangtu2022.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://wangtu2022.github.io/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-166045776-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
