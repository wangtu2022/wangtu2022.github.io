<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="迷惑了，Go len() 是怎么计算出来的？">
<meta itemprop="description" content="大家好，我是煎鱼。
最近看到了一个很有意思的话题，我们平时常常会用 Go 的内置函数 len 去获取各种 map、slice 的长度，那他是怎么实现的呢？
正当我想去看看 len 的具体实现时，一展身手，却发现竟然是个空方法：
func len(v Type) int 看注解也没有 link 到其他 runtime 函数，那么 len 函数是如何被调用的呢？
先前看国外讨论 Go 计算 len 的文章时做了一些翻译和笔记（底下有参考链接），在此分享给大家，共同进步。
谜底 今天就由煎鱼带大家一同解开这个谜底。既然是谜底，那就一开始就揭开。
其实 Go 语言中并没有 len 函数的具体实现代码，他其实是 Go 编译器的 &ldquo;魔法&rdquo; ，不是实际的函数调用。"><meta itemprop="datePublished" content="2021-12-31T12:54:58+08:00" />
<meta itemprop="dateModified" content="2021-12-31T12:54:58+08:00" />
<meta itemprop="wordCount" content="396">
<meta itemprop="keywords" content="go," /><meta property="og:title" content="迷惑了，Go len() 是怎么计算出来的？" />
<meta property="og:description" content="大家好，我是煎鱼。
最近看到了一个很有意思的话题，我们平时常常会用 Go 的内置函数 len 去获取各种 map、slice 的长度，那他是怎么实现的呢？
正当我想去看看 len 的具体实现时，一展身手，却发现竟然是个空方法：
func len(v Type) int 看注解也没有 link 到其他 runtime 函数，那么 len 函数是如何被调用的呢？
先前看国外讨论 Go 计算 len 的文章时做了一些翻译和笔记（底下有参考链接），在此分享给大家，共同进步。
谜底 今天就由煎鱼带大家一同解开这个谜底。既然是谜底，那就一开始就揭开。
其实 Go 语言中并没有 len 函数的具体实现代码，他其实是 Go 编译器的 &ldquo;魔法&rdquo; ，不是实际的函数调用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangtu2022.github.io/posts/go/len/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-31T12:54:58+08:00" />
<meta property="article:modified_time" content="2021-12-31T12:54:58+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="迷惑了，Go len() 是怎么计算出来的？"/>
<meta name="twitter:description" content="大家好，我是煎鱼。
最近看到了一个很有意思的话题，我们平时常常会用 Go 的内置函数 len 去获取各种 map、slice 的长度，那他是怎么实现的呢？
正当我想去看看 len 的具体实现时，一展身手，却发现竟然是个空方法：
func len(v Type) int 看注解也没有 link 到其他 runtime 函数，那么 len 函数是如何被调用的呢？
先前看国外讨论 Go 计算 len 的文章时做了一些翻译和笔记（底下有参考链接），在此分享给大家，共同进步。
谜底 今天就由煎鱼带大家一同解开这个谜底。既然是谜底，那就一开始就揭开。
其实 Go 语言中并没有 len 函数的具体实现代码，他其实是 Go 编译器的 &ldquo;魔法&rdquo; ，不是实际的函数调用。"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>迷惑了，Go len() 是怎么计算出来的？</title>
	<link rel="stylesheet" href="https://wangtu2022.github.io/css/style.min.d3141168199607bf3a517216ce3c263814eecdbc8fca72a9a88700799a838219.css" integrity="sha256-0xQRaBmWB786UXIWzjwmOBTuzbyPynKpqIcAeZqDghk=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
	<link rel="stylesheet" href="https://wangtu2022.github.io/css/styles.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://wangtu2022.github.io/">煎鱼</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://wangtu2022.github.io/posts/">文章</a>
				<a href="https://wangtu2022.github.io/tags/">标签</a>
				<a href="https://wangtu2022.github.io/about/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/eddycjy" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://wangtu2022.github.io/posts/">文章</a></li>
			<li><a href="https://wangtu2022.github.io/tags/">标签</a></li>
			<li><a href="https://wangtu2022.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Dec 31, 2021</span></div>
				<h1>迷惑了，Go len() 是怎么计算出来的？</h1>
			</header>
			<div class="content">
				<p>大家好，我是煎鱼。</p>
<p>最近看到了一个很有意思的话题，我们平时常常会用 Go 的内置函数 <code>len</code> 去获取各种 map、slice 的长度，那他是怎么实现的呢？</p>
<p>正当我想去看看 <code>len</code> 的具体实现时，一展身手，却发现竟然是个空方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">int</span>
</span></span></code></pre></div><p>看注解也没有 link 到其他 runtime 函数，那么 len 函数是如何被调用的呢？</p>
<p>先前看国外讨论 Go 计算 len 的文章时做了一些翻译和笔记（底下有参考链接），在此分享给大家，共同进步。</p>
<h2 id="谜底">谜底<a href="#谜底" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>今天就由煎鱼带大家一同解开这个谜底。既然是谜底，那就一开始就揭开。</p>
<p>其实 Go 语言中并没有 len 函数的具体实现代码，他其实<strong>是 Go 编译器的 &ldquo;魔法&rdquo; ，不是实际的函数调用</strong>。</p>
<p>接下来将展开这部分，我们可以更深入地了解 Go 编译器的内部工作原理。</p>
<h2 id="编译器">编译器<a href="#编译器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在 Go 编译器编译时会解析命令行参数中指定的标志和 Go 源文件，对解析后的 Go 包进行类型检查，将函数编译为机器代码。代码，最后将编译后的包定义写到磁盘上。</p>
<p>内部定义基本类型、内置函数和操作函数的阶段是在 types/universe.go 当中。同时会进行内置函数和具体的操作符匹配，可以明确知道内置函数 len 对应的是 OLEN：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">builtinFuncs</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">op</span>   <span class="nx">Op</span>
</span></span><span class="line"><span class="cl"><span class="p">}{</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;append&#34;</span><span class="p">,</span> <span class="nx">OAPPEND</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;cap&#34;</span><span class="p">,</span> <span class="nx">OCAP</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;close&#34;</span><span class="p">,</span> <span class="nx">OCLOSE</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;complex&#34;</span><span class="p">,</span> <span class="nx">OCOMPLEX</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;copy&#34;</span><span class="p">,</span> <span class="nx">OCOPY</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;delete&#34;</span><span class="p">,</span> <span class="nx">ODELETE</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;imag&#34;</span><span class="p">,</span> <span class="nx">OIMAG</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;len&#34;</span><span class="p">,</span> <span class="nx">OLEN</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在编译时，上分为五个阶段进行类型检查：</p>
<ul>
<li>第一阶段：常量、类型、以及函数的名称和类型。</li>
<li>第二阶段：变量赋值、接口赋值、别名声明。</li>
<li>第三阶段：类型检查函数体。</li>
<li>第四阶段：检查外部声明。</li>
<li>第五阶段：检查类型的地图键，未使用的导入。</li>
</ul>
<p>如果最后一个类型检查阶段遇到 len 函数，就会转换为 UnaryExpr 类型，一个 UnaryExpr 节点代表一个单数表达式，也最终就是不会成为函数调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">typecheck1</span><span class="p">(</span><span class="nx">n</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">top</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.(</span><span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">Name</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typecheckdef</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nf">Op</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">OCAP</span><span class="p">,</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">OLEN</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.(</span><span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">UnaryExpr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">tcLenCap</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在调用 <code>*ir.UnaryExpr</code> 转换完毕后，会调用 <code>tcLenCap</code>，也就是 typecheck，使用 okforlen 数组来验证参数的合法性或发出相关错误信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">tcLenCap</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">UnaryExpr</span><span class="p">)</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nf">Expr</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nf">DefaultLit</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nf">implicitstar</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nf">Op</span><span class="p">()</span> <span class="o">==</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">OLEN</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ok</span> <span class="p">=</span> <span class="nx">okforlen</span><span class="p">[</span><span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ok</span> <span class="p">=</span> <span class="nx">okforcap</span><span class="p">[</span><span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nf">SetType</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">types</span><span class="p">.</span><span class="nx">TINT</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>经历过上面的步骤后在对所有内容进行类型检查后，所有函数都将排队等待编译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl">	<span class="nx">base</span><span class="p">.</span><span class="nx">Timer</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;be&#34;</span><span class="p">,</span> <span class="s">&#34;compilefuncs&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fcount</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">typecheck</span><span class="p">.</span><span class="nx">Target</span><span class="p">.</span><span class="nx">Decls</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">typecheck</span><span class="p">.</span><span class="nx">Target</span><span class="p">.</span><span class="nx">Decls</span><span class="p">[</span><span class="nx">i</span><span class="p">].(</span><span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">Func</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">enqueueFunc</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fcount</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">base</span><span class="p">.</span><span class="nx">Timer</span><span class="p">.</span><span class="nf">AddEvent</span><span class="p">(</span><span class="nx">fcount</span><span class="p">,</span> <span class="s">&#34;funcs&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">compileFunctions</span><span class="p">()</span>
</span></span></code></pre></div><p>在经过在 buildssa 和 genssa 之后，再深入几层，就会将 AST 树中的 len 表达式转换为 SSA。接着我们就可以看到 Go 语言中的每种类型的长度是怎么获取的。</p>
<p>这块的处理对应 internal/ssagen/ssa.go 的 expr 方法，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">OLEN</span><span class="p">,</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">OCAP</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.(</span><span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">UnaryExpr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">IsSlice</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">			<span class="nx">op</span> <span class="o">:=</span> <span class="nx">ssa</span><span class="p">.</span><span class="nx">OpSliceLen</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nf">Op</span><span class="p">()</span> <span class="o">==</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">OCAP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">op</span> <span class="p">=</span> <span class="nx">ssa</span><span class="p">.</span><span class="nx">OpSliceCap</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">types</span><span class="p">.</span><span class="nx">TINT</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nf">expr</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">IsString</span><span class="p">():</span> <span class="c1">// string; not reachable for OCAP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpStringLen</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">types</span><span class="p">.</span><span class="nx">TINT</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nf">expr</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">IsMap</span><span class="p">(),</span> <span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">IsChan</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">referenceTypeBuiltin</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">expr</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span> <span class="c1">// array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constInt</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">types</span><span class="p">.</span><span class="nx">TINT</span><span class="p">],</span> <span class="nx">n</span><span class="p">.</span><span class="nx">X</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">NumElem</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span></code></pre></div><p>若是数组（array）类型，则会调用 <code>NumElem</code> 方法来获取长度值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Array</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Elem</span>  <span class="o">*</span><span class="nx">Type</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">Bound</span> <span class="kt">int64</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Type</span><span class="p">)</span> <span class="nf">NumElem</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nf">wantEtype</span><span class="p">(</span><span class="nx">TARRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Extra</span><span class="p">.(</span><span class="o">*</span><span class="nx">Array</span><span class="p">).</span><span class="nx">Bound</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>若是字典（map）类型或通道（channel），将会调用 <code>referenceTypeBuiltin</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">referenceTypeBuiltin</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">UnaryExpr</span><span class="p">,</span> <span class="nx">x</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lenType</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nilValue</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constNil</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">types</span><span class="p">.</span><span class="nx">TUINTPTR</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cmp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue2</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpEqPtr</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">types</span><span class="p">.</span><span class="nx">TBOOL</span><span class="p">],</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">nilValue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">endBlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">Kind</span> <span class="p">=</span> <span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockIf</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nf">SetControl</span><span class="p">(</span><span class="nx">cmp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">Likely</span> <span class="p">=</span> <span class="nx">ssa</span><span class="p">.</span><span class="nx">BranchUnlikely</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">bThen</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nf">NewBlock</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockPlain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bElse</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nf">NewBlock</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockPlain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bAfter</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nf">NewBlock</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockPlain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nf">Op</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">OLEN</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="nx">lenType</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">variable</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">lenType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该函数的作用是是获取 map 或chan 的内存地址，并以零偏移量引用其结构布局，就像 <code>unsafe.Pointer(uintptr(unsafe.Pointer(s))</code> 一样，返回第一个字面字段的值。</p>
<p>那为什么要获取结构体的第一个字段的值呢，应该是和 map 和 chan 的基础数据结构有关：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">count</span>     <span class="kt">int</span> 
</span></span><span class="line"><span class="cl">  <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">qcount</span>   <span class="kt">uint</span>    
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>是因为 map 和 chan 的基础数据结构的第一个字段就表示长度，自然也就通过计算偏移值来获取了。</p>
<p>其他的数据类型，大家可以继续深入代码，再细看就好了。主要还是枚举多同类的数据类型，接着调用相应的方法。</p>
<h2 id="总结">总结<a href="#总结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>每次我们看到内置函数时，总会下意识的以为是在 runtime 内实现的。看不到 runtime 内的实现方法，又会以为是通过注解 link 的方式来解决的。</p>
<p>但需要注意，其实还有像 len 内置函数这种直接编译器转换的，这也是一种不错的优化方式。</p>
<h2 id="参考">参考<a href="#参考" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<ul>
<li><a href="https://tpaschalis.github.io/golang-len">https://tpaschalis.github.io/golang-len</a></li>
<li><a href="https://stackoverflow.com/questions/28204831/how-do-os-len-and-make-functions-work">https://stackoverflow.com/questions/28204831/how-do-os-len-and-make-functions-work</a></li>
</ul>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://wangtu2022.github.io/tags/go">go</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>396 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-12-31 12:54 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc">
			<div class="toc-title">Table of Contents</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#谜底">谜底</a></li>
    <li><a href="#编译器">编译器</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://wangtu2022.github.io/posts/go/plugin/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Go 插件系统，一个凉了快半截的特性？</span>
			</a>
			<a class="prev-post" href="https://wangtu2022.github.io/posts/go/news-slices-maps/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Go 提案：增加泛型版 slices 和 maps 新包</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://wangtu2022.github.io/">煎鱼</a> &#183; <a href="http://www.beian.miit.gov.cn/">粤ICP备19076352号</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://wangtu2022.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://wangtu2022.github.io/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-166045776-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
