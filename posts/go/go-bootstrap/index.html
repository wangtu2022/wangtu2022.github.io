<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Go 应用程序是怎么运行起来的？">
<meta itemprop="description" content="自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：
import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world.&#34;) } 这段程序的输出结果为 hello world.，就是这么的简单又直接。但这时候又不禁思考了起来，这个 hello world. 是怎么输出来，经历了什么过程。
真是非常的好奇，今天我们就通过这篇文章来一探究竟。
引导阶段 查找入口 开始剖析之路，首先编译上文提到的示例程序：
$ GOFLAGS=&#34;-ldflags=-compressdwarf=false&#34; go build 在命令中指定了 GOFLAGS 参数，这是因为在 Go1."><meta itemprop="datePublished" content="2020-10-08T15:57:18+08:00" />
<meta itemprop="dateModified" content="2020-10-08T15:57:18+08:00" />
<meta itemprop="wordCount" content="287">
<meta itemprop="keywords" content="go," /><meta property="og:title" content="Go 应用程序是怎么运行起来的？" />
<meta property="og:description" content="自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：
import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world.&#34;) } 这段程序的输出结果为 hello world.，就是这么的简单又直接。但这时候又不禁思考了起来，这个 hello world. 是怎么输出来，经历了什么过程。
真是非常的好奇，今天我们就通过这篇文章来一探究竟。
引导阶段 查找入口 开始剖析之路，首先编译上文提到的示例程序：
$ GOFLAGS=&#34;-ldflags=-compressdwarf=false&#34; go build 在命令中指定了 GOFLAGS 参数，这是因为在 Go1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangtu2022.github.io/posts/go/go-bootstrap/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-08T15:57:18+08:00" />
<meta property="article:modified_time" content="2020-10-08T15:57:18+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 应用程序是怎么运行起来的？"/>
<meta name="twitter:description" content="自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：
import &#34;fmt&#34; func main() { fmt.Println(&#34;hello world.&#34;) } 这段程序的输出结果为 hello world.，就是这么的简单又直接。但这时候又不禁思考了起来，这个 hello world. 是怎么输出来，经历了什么过程。
真是非常的好奇，今天我们就通过这篇文章来一探究竟。
引导阶段 查找入口 开始剖析之路，首先编译上文提到的示例程序：
$ GOFLAGS=&#34;-ldflags=-compressdwarf=false&#34; go build 在命令中指定了 GOFLAGS 参数，这是因为在 Go1."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Go 应用程序是怎么运行起来的？</title>
	<link rel="stylesheet" href="https://wangtu2022.github.io/css/style.min.d3141168199607bf3a517216ce3c263814eecdbc8fca72a9a88700799a838219.css" integrity="sha256-0xQRaBmWB786UXIWzjwmOBTuzbyPynKpqIcAeZqDghk=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
	<link rel="stylesheet" href="https://wangtu2022.github.io/css/styles.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://wangtu2022.github.io/">煎鱼</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://wangtu2022.github.io/posts/">文章</a>
				<a href="https://wangtu2022.github.io/tags/">标签</a>
				<a href="https://wangtu2022.github.io/about/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/eddycjy" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://wangtu2022.github.io/posts/">文章</a></li>
			<li><a href="https://wangtu2022.github.io/tags/">标签</a></li>
			<li><a href="https://wangtu2022.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Oct 8, 2020</span></div>
				<h1>Go 应用程序是怎么运行起来的？</h1>
			</header>
			<div class="content">
				<p>自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：</p>
<pre tabindex="0"><code>import &#34;fmt&#34;

func main() {
	fmt.Println(&#34;hello world.&#34;)
}
</code></pre><p>这段程序的输出结果为 <code>hello world.</code>，就是这么的简单又直接。但这时候又不禁思考了起来，这个 <code>hello world.</code> 是怎么输出来，经历了什么过程。</p>
<p>真是非常的好奇，今天我们就通过这篇文章来一探究竟。</p>
<h2 id="引导阶段">引导阶段<a href="#引导阶段" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="查找入口">查找入口<a href="#查找入口" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>开始剖析之路，首先编译上文提到的示例程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">&#34;-ldflags=-compressdwarf=false&#34;</span> go build 
</span></span></code></pre></div><p>在命令中指定了 GOFLAGS 参数，这是因为在 Go1.11 起，为了减少二进制文件大小，调试信息会被压缩。导致在 MacOS 上使用 gdb 时无法理解压缩的 DWARF 的含义是什么（而我恰恰就是用的 MacOS）。</p>
<p>因此需要在本次调试中将其关闭，再使用 gdb 进行调试，以此达到观察的目的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ gdb awesomeProject 
</span></span><span class="line"><span class="cl"><span class="o">(</span>gdb<span class="o">)</span> info files
</span></span><span class="line"><span class="cl">Symbols from <span class="s2">&#34;/Users/eddycjy/go-application/awesomeProject/awesomeProject&#34;</span>.
</span></span><span class="line"><span class="cl">Local <span class="nb">exec</span> file:
</span></span><span class="line"><span class="cl">	<span class="sb">`</span>/Users/eddycjy/go-application/awesomeProject/awesomeProject<span class="err">&#39;</span>, file <span class="nb">type</span> mach-o-x86-64.
</span></span><span class="line"><span class="cl">	Entry point: 0x1063c80
</span></span><span class="line"><span class="cl">	0x0000000001001000 - 0x00000000010a6aca is .text
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl"><span class="o">(</span>gdb<span class="o">)</span> b *0x1063c80
</span></span><span class="line"><span class="cl">Breakpoint <span class="m">1</span> at 0x1063c80: file /usr/local/Cellar/go/1.15/libexec/src/runtime/rt0_darwin_amd64.s, line 8.
</span></span></code></pre></div><p>通过 Entry point 的调试，可看到真正的程序入口在 runtime 包中，不同的计算机架构指向不同，例如：MacOS 在 <code>src/runtime/rt0_darwin_amd64.s</code>，Linux 在 <code>src/runtime/rt0_linux_amd64.s</code>。</p>
<pre tabindex="0"><code>Breakpoint 1 at 0x1063c80: file /usr/local/Cellar/go/1.15/libexec/src/runtime/rt0_darwin_amd64.s, line 8.
</code></pre><p>其最终指向了 rt0_darwin_amd64.s 文件，这个文件名称非常的直观，rt0 代表 runtime0 的缩写，指代运行时的创世，超级奶爸；darwin 代表目标操作系统（GOOS），amd64 代表目标操作系统架构（GOHOSTARCH）。</p>
<p>同时 Go 语言还支持更多的目标系统架构，例如：AMD64、AMR、MIPS、WASM 等：</p>
<p><img src="https://image.eddycjy.com/981720dfbce750bec26fc394e97d9ff7.jpg" alt="image"></p>
<p>若有兴趣可到 <code>src/runtime</code> 目录下进一步查看。</p>
<h3 id="入口方法">入口方法<a href="#入口方法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在 rt0_linux_amd64.s 文件中，可发现 <code>_rt0_amd64_darwin</code> JMP 跳转到了 <code>_rt0_amd64</code> 方法：</p>
<pre tabindex="0"><code>TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB)
...
</code></pre><p>紧接着又跳转到 <code>runtime·rt0_go</code> 方法：</p>
<pre tabindex="0"><code>TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB)
</code></pre><p>该方法将程序输入的 argc 和 argv 从内存移动到寄存器中。栈指针（SP）的前两个值分别是 argc 和 argv，其对应参数的数量和具体各参数的值。</p>
<h3 id="开启主线">开启主线<a href="#开启主线" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>程序参数准备就绪后，正式初始化的方法落在 <code>runtime·rt0_go</code> 方法中：</p>
<pre tabindex="0"><code>TEXT runtime·rt0_go(SB),NOSPLIT,$0
	...
	CALL	runtime·check(SB)
	MOVL	16(SP), AX		// copy argc
	MOVL	AX, 0(SP)
	MOVQ	24(SP), AX		// copy argv
	MOVQ	AX, 8(SP)
	CALL	runtime·args(SB)
	CALL	runtime·osinit(SB)
	CALL	runtime·schedinit(SB)

	// create a new goroutine to start program
	MOVQ	$runtime·mainPC(SB), AX		// entry
	PUSHQ	AX
	PUSHQ	$0			// arg size
	CALL	runtime·newproc(SB)
	POPQ	AX
	POPQ	AX

	// start this M
	CALL	runtime·mstart(SB)
	...
</code></pre><ul>
<li>
<p>runtime.check：运行时类型检查，主要是校验编译器的翻译工作是否正确，是否有 “坑”。基本代码均为检查 <code>int8</code> 在 <code>unsafe.Sizeof</code> 方法下是否等于 1 这类动作。</p>
</li>
<li>
<p>runtime.args：系统参数传递，主要是将系统参数转换传递给程序使用。</p>
</li>
<li>
<p>runtime.osinit：系统基本参数设置，主要是获取 CPU 核心数和内存物理页大小。</p>
</li>
<li>
<p>runtime.schedinit：进行各种运行时组件的初始化，包含调度器、内存分配器、堆、栈、GC 等一大堆初始化工作。是后续的重点关注对象。</p>
</li>
<li>
<p>runtime·main：主要工作是运行 main goroutine，虽然在<code>runtime·rt0_go</code> 中指向的是<code>$runtime·mainPC</code> ，但实质指向的是 <code>runtime.main</code>。</p>
</li>
<li>
<p>runtime.newproc：创建一个新的 goroutine 将其放入 g 的等待运行队列中去。且绑定 <code>runtime.main</code> 方法，也就是应用程序中的入口 main 方法。</p>
</li>
<li>
<p>runtime.mstart：调度器开始进行循环调度。</p>
</li>
</ul>
<p>在 <code>runtime·rt0_go</code> 方法中，其主要是完成各类运行时的检查，系统参数设置和获取，并进行大量的 Go 基础组件初始化。初始化完毕后进行 main goroutine 的运行，并放入等待队列（GMP），最后调度器开始进行循环调度。</p>
<h2 id="总结">总结<a href="#总结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>根据上述源码剖析，可以得出如下 Go 应用程序引导的流程图：</p>
<p><img src="https://image.eddycjy.com/057c1ccb06c16e8c5f38ff5800e3fa63.jpg" alt="image"></p>
<p>在 Go 语言中，实际的运行入口并不是用户日常所写的 <code>main func</code>，更不是 <code>runtime.main</code> 方法，而是从 <code>rt0_*_amd64.s</code> 开始，最终再一路 JMP 到 <code>runtime·rt0_go</code> 里去，再在该方法里完成一系列 Go 自身所需要完成的绝大部分初始化动作。</p>
<p>其中包括运行时类型检查、系统参数传递、CPU 核数获取及设置、运行时组件的初始化（调度器、内存分配器、堆、栈、GC 等）、运行 main goroutine 和相应的 GMP 等大量缺省行为，还会涉及到调度器相关的大量知识。</p>
<p>后续将会继续剖析将进一步剖析 <code>runtime·rt0_go</code> 里的爱与恨，尤其像是 <code>runtime.main</code>、<code>runtime.schedinit</code> 等调度方法，都有非常大的学习价值，有兴趣的小伙伴可以持续关注。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://wangtu2022.github.io/tags/go">go</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>287 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-10-08 15:57 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc">
			<div class="toc-title">Table of Contents</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#引导阶段">引导阶段</a>
      <ul>
        <li><a href="#查找入口">查找入口</a></li>
        <li><a href="#入口方法">入口方法</a></li>
        <li><a href="#开启主线">开启主线</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://wangtu2022.github.io/posts/reading/programmer-accom-base/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>必知必会！计算机里一些基本又重要的概念</span>
			</a>
			<a class="prev-post" href="https://wangtu2022.github.io/posts/microservice/leaky-token-buckets/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>带你快速了解：限流中的漏桶和令牌桶算法</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2022 <a href="https://wangtu2022.github.io/">煎鱼</a> &#183; <a href="http://www.beian.miit.gov.cn/">粤ICP备19076352号</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://wangtu2022.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://wangtu2022.github.io/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js" integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin="anonymous"></script>
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-166045776-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
