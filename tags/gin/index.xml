<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gin on 煎鱼</title>
    <link>https://wangtu2022.github.io/tags/gin/</link>
    <description>Recent content in gin on 煎鱼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 01 Sep 2018 12:00:00 +0000</lastBuildDate><atom:link href="https://wangtu2022.github.io/tags/gin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「连载十七」用Nginx部署Go应用</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-09-01-nginx/</link>
      <pubDate>Sat, 01 Sep 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-09-01-nginx/</guid>
      <description>知识点 Nginx。 反向代理。 本文目标 简单部署后端服务。
做什么 在本章节，我们将简单介绍 Nginx 以及使用 Nginx 来完成对 go-gin-example 的部署，会实现反向代理和简单负载均衡的功能。
Nginx 是什么 Nginx 是一个 Web Server，可以用作反向代理、负载均衡、邮件代理、TCP / UDP、HTTP 服务器等等，它拥有很多吸引人的特性，例如：
以较低的内存占用率处理 10,000 多个并发连接（每 10k 非活动 HTTP 保持活动连接约 2.5 MB ） 静态服务器（处理静态文件） 正向、反向代理 负载均衡 通过 OpenSSL 对 TLS / SSL 与 SNI 和 OCSP 支持 FastCGI、SCGI、uWSGI 的支持 WebSockets、HTTP/1.</description>
    </item>
    
    <item>
      <title>「番外」请入门 Makefile</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-08-26-makefile/</link>
      <pubDate>Sun, 26 Aug 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-08-26-makefile/</guid>
      <description>知识点 写一个 Makefile 本文目标 含一定复杂度的软件工程，基本上都是先编译 A，再依赖 B，再编译 C&amp;hellip;，最后才执行构建。如果每次都人为编排，又或是每新来一个同事就问你项目 D 怎么构建、重新构建需要注意什么&amp;hellip;等等情况，岂不是要崩溃？
我们常常会在开源项目中发现 Makefile，你是否有过疑问？
本章节会简单介绍 Makefile 的使用方式，最后建议深入学习。
怎么解决 对于构建编排，Docker 有 Dockerfile ，在 Unix 中有神器 Make &amp;hellip;.
Make 是什么 Make 是一个构建自动化工具，会在当前目录下寻找 Makefile 或 makefile 文件。如果存在，会依据 Makefile 的构建规则去完成构建</description>
    </item>
    
    <item>
      <title>「连载十六」在图片上绘制文字</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-07-07-font/</link>
      <pubDate>Sat, 07 Jul 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-07-07-font/</guid>
      <description>知识点 字体库使用 图片合成 本文目标 主要实现合并后的海报上绘制文字的功能（这个需求也是常见的很了），内容比较简单。
实现 这里使用的是 微软雅黑 的字体，请点击进行下载并存放到 runtime/fonts 目录下（字体文件占 16 MB 大小）
安装 $ go get -u github.com/golang/freetype 绘制文字 打开 service/article_service/article_poster.go 文件，增加绘制文字的业务逻辑，如下：
type DrawText struct { JPG draw.Image Merged *os.</description>
    </item>
    
    <item>
      <title>「连载十五」生成二维码、合并海报</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-07-05-image/</link>
      <pubDate>Thu, 05 Jul 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-07-05-image/</guid>
      <description>知识点 图片生成 二维码生成 本文目标 在文章的详情页中，我们常常会需要去宣传它，而目前最常见的就是发海报了，今天我们将实现如下功能：
生成二维码
合并海报（背景图 + 二维码）
实现 首先，你需要在 App 配置项中增加二维码及其海报的存储路径，我们约定配置项名称为 QrCodeSavePath，值为 qrcode/，经过多节连载的你应该能够完成，若有不懂可参照 go-gin-example。
生成二维码 安装 $ go get -u github.com/boombuler/barcode 工具包 考虑生成二维码这一动作贴合工具包的定义，且有公用的可能性，新建 pkg/qrcode/qrcode.go 文件，写入内容：
package qrcode import ( &amp;#34;image/jpeg&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>「连载十四」实现导出、导入 Excel</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-06-14-excel/</link>
      <pubDate>Thu, 14 Jun 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-06-14-excel/</guid>
      <description>知识点 导出功能的实现 本文目标 在本节，我们将实现对标签信息的导出、导入功能，这是很标配功能了，希望你掌握基础的使用方式。
另外在本文我们使用了 2 个 Excel 的包，excelize 最初的 XML 格式文件的一些结构，是通过 tealeg/xlsx 格式文件结构演化而来的，因此特意在此都展示了，你可以根据自己的场景和喜爱去使用。
配置 首先要指定导出的 Excel 文件的存储路径，在 app.ini 中增加配置：
[app] ... ExportSavePath = export/ 修改 setting.go 的 App struct：</description>
    </item>
    
    <item>
      <title>「连载十三」优化你的应用结构和实现Redis缓存</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-06-02-application-redis/</link>
      <pubDate>Sat, 02 Jun 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-06-02-application-redis/</guid>
      <description>前言 之前就在想，不少教程或示例的代码设计都是一步到位的（也没问题）
但实际操作的读者真的能够理解透彻为什么吗？左思右想，有了今天这一章的内容，我认为实际经历过一遍印象会更加深刻
本文目标 在本章节，将介绍以下功能的整理：
抽离、分层业务逻辑：减轻 routers.go 内的 api 方法的逻辑（但本文暂不分层 repository，这块逻辑还不重）。 增加容错性：对 gorm 的错误进行判断。 Redis 缓存：对获取数据类的接口增加缓存设置。 减少重复冗余代码。 问题在哪？ 在规划阶段我们发现了一个问题，这是目前的伪代码：
if ! HasErrors() { if ExistArticleByID(id) { DeleteArticle(id) code = e.SUCCESS } else { code = e.</description>
    </item>
    
    <item>
      <title>「连载十二」优化配置结构及实现图片上传</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-05-27-config-upload/</link>
      <pubDate>Sun, 27 May 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-05-27-config-upload/</guid>
      <description>知识点 重构、调整结构 本文目标 这个应用程序跑了那么久了，越来越大，越来越壮，仿佛我们的产品一样，现在它需要进行小范围重构了，以便于后续的使用，这非常重要。
前言 一天，产品经理突然跟你说文章列表，没有封面图，不够美观，！）&amp;amp;￥*！&amp;amp;）#&amp;amp;￥*！加一个吧，几分钟的事
你打开你的程序，分析了一波写了个清单：
优化配置结构（因为配置项越来越多） 抽离 原 logging 的 File 便于公用（logging、upload 各保有一份并不合适） 实现上传图片接口（需限制文件格式、大小） 修改文章接口（需支持封面地址参数） 增加 blog_article （文章）的数据库字段 实现 http.FileServer 嗯，你发现要较优的话，需要调整部分的应用程序结构，因为功能越来越多，原本的设计也要跟上节奏
也就是在适当的时候，及时优化
优化配置结构 一、讲解 在先前章节中，采用了直接读取 KEY 的方式去存储配置项，而本次需求中，需要增加图片的配置项，总体就有些冗余了
我们采用以下解决方法：</description>
    </item>
    
    <item>
      <title>「连载十一」Cron定时任务</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-04-29-cron/</link>
      <pubDate>Sun, 29 Apr 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-04-29-cron/</guid>
      <description>知识点 完成定时任务的功能 本文目标 在实际的应用项目中，定时任务的使用是很常见的。你是否有过 Golang 如何做定时任务的疑问，莫非是轮询，在本文中我们将结合我们的项目讲述 Cron。
介绍 我们将使用 cron 这个包，它实现了 cron 规范解析器和任务运行器，简单来讲就是包含了定时任务所需的功能
Cron 表达式格式 字段名 是否必填 允许的值 允许的特殊字符 秒（Seconds） Yes 0-59 * / , - 分（Minutes） Yes 0-59 * / , - 时（Hours） Yes 0-23 * / , - 一个月中的某天（Day of month） Yes 1-31 * / , - ?</description>
    </item>
    
    <item>
      <title>「连载十」定制 GORM Callbacks</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-04-15-gorm-callback/</link>
      <pubDate>Sun, 15 Apr 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-04-15-gorm-callback/</guid>
      <description>涉及知识点 GORM 本文目标 GORM itself is powered by Callbacks, so you could fully customize GORM as you want
GORM 本身是由回调驱动的，所以我们可以根据需要完全定制 GORM，以此达到我们的目的，如下：
注册一个新的回调 删除现有的回调 替换现有的回调 注册回调的顺序 在 GORM 中包含以上四类 Callbacks，我们结合项目选用 “替换现有的回调” 来解决一个小痛点。</description>
    </item>
    
    <item>
      <title>「番外」Golang 交叉编译</title>
      <link>https://wangtu2022.github.io/posts/go/gin/2018-03-26-cgo/</link>
      <pubDate>Mon, 26 Mar 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/gin/2018-03-26-cgo/</guid>
      <description>知识点 跨平台编译 本文目标 在 连载九 讲解构建 Scratch 镜像时，我们编译可执行文件用了另外一个形式的命令，如下：
$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o go-gin-example . 我想你可能会有疑问，今天本文会针对这块进行讲解。
说明 我们将讲解命令各个参数的作用，希望你在阅读时，将每一项串联起来，你会发现这就是交叉编译相关的小知识
也就是 Golang 令人心动的特性之一跨平台编译
一、CGO_ENABLED 作用：
用于标识（声明） cgo 工具是否可用</description>
    </item>
    
  </channel>
</rss>
