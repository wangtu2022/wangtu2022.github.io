<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mq on 煎鱼</title>
    <link>https://wangtu2022.github.io/tags/mq/</link>
    <description>Recent content in mq on 煎鱼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 31 Dec 2021 12:54:50 +0800</lastBuildDate><atom:link href="https://wangtu2022.github.io/tags/mq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《漫谈 MQ》要消息队列（MQ）有什么用？</title>
      <link>https://wangtu2022.github.io/posts/why-mq/</link>
      <pubDate>Fri, 31 Dec 2021 12:54:50 +0800</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/why-mq/</guid>
      <description>大家好，我是煎鱼。想是问题，做是答案。
最近我有一个朋友公司踩了不少消息队列（MQ）的坑，让人无奈不已。因此计划写 MQ 系列的技术文章，来科普更多这块的知识。
目前 MQ 也是互联网应用中非常常用的基础组件了，面试特爱问。基本有一定规模的系统都能看见他的踪影。
无论是 RocketMQ、Kafka、RabbitMQ 等，都围绕着根本的设计出发产生不同的高级功能，甚至可能是雷同的设计有 N 个名字。
什么是 MQ MQ 一般代指消息队列（Message Queue）。它是一个抽象层，允许多个进程（可能在不同的机器上）通过各种模式（例如：点对点，发布订阅等）进行通信。
也可以根据不同的实现，它可以被配置为保证可靠性、错误报告、安全、发现、性能等。
为什么需要 MQ 在当下 MQ 的必要场景，比较经典的说辞就是 “异步、削峰、解耦”。是各类秒杀系统的设计核心，甚至会作为不少云厂商的卖点，每家都有自己的生态圈。
核心分为三个要点：
解耦。 削峰。 异步。 解耦 在业务系统设计中，我们常常会与一个平台系统 A，他汇聚了许许多多的系统的对接。例如，系统 A 作为平台拥有大量用户操作，自然就有非常多的用户行为。</description>
    </item>
    
    <item>
      <title>《漫谈 MQ》设计 MQ 的 3 个难点</title>
      <link>https://wangtu2022.github.io/posts/mq-nodus/</link>
      <pubDate>Fri, 31 Dec 2021 12:54:50 +0800</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/mq-nodus/</guid>
      <description>大家好，我是煎鱼。
前段时间我们分享了漫谈 MQ 的第一期《要消息队列（MQ）有什么用？》，感觉打开了一个新的世界。
但很快就有小伙伴意识到了不妙，既然 MQ 承接了多个系统，那岂不是该有的问题，他都有，又或是更甚。如下：
今天我们就进一步讲讲，设计 MQ 时很有可能会遇到的几个大难点，在业内又配套用了什么解决方案去处理。
几个难点 从结论上来看，设计 MQ 这一个存在。会至少引发三大难点。堪称互联网经典的，也是面试官们最爱问的：
高可用：代表系统的可用性程度，高可用性通常通过提高系统的容错能力来实现，从而减少系统宕机时间。 高并发：代表通过设计保证系统能够同时并行处理很多请求，在同一个时间点，有很多用户同时访问同一系统、API、URL。 高可靠：代表能够满足预计条件的一个系统或组件（例如：备份、故障处理、数据存储以及访问），比较经典的是 4 个9 等标准。 高可用 像前面评论区留言的兄弟截图表述的一样。
虽然请求不直接找系统 A、B、C、D 了。但是请求都实打实的通过异步的方式打到了 MQ 上，就可以不断往 MQ 塞，变成了多个系统都在请求 MQ，可以认为压力比单系统同步调用大了不止一倍。</description>
    </item>
    
  </channel>
</rss>
