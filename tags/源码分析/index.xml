<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码分析 on 煎鱼</title>
    <link>https://wangtu2022.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 源码分析 on 煎鱼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 27 May 2019 12:30:00 +0000</lastBuildDate><atom:link href="https://wangtu2022.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入理解 Go defer</title>
      <link>https://wangtu2022.github.io/posts/go/defer/2019-05-27-defer/</link>
      <pubDate>Mon, 27 May 2019 12:30:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/defer/2019-05-27-defer/</guid>
      <description>在上一章节 《深入理解 Go panic and recover》中，我们发现了 defer 与其关联性极大，还是觉得非常有必要深入一下。希望通过本章节大家可以对 defer 关键字有一个深刻的理解，那么我们开始吧。你先等等，请排好队，我们这儿采取后进先出 LIFO 的出站方式&amp;hellip;
特性 我们简单的过一下 defer 关键字的基础使用，让大家先有一个基础的认知
一、延迟调用 func main() { defer log.Println(&amp;#34;EDDYCJY.&amp;#34;) log.Println(&amp;#34;end.&amp;#34;) } 输出结果：
$ go run main.go 2019/05/19 21:15:02 end.</description>
    </item>
    
    <item>
      <title>深入理解 Go panic and recover</title>
      <link>https://wangtu2022.github.io/posts/go/panic/2019-05-21-panic-and-recover/</link>
      <pubDate>Tue, 21 May 2019 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/panic/2019-05-21-panic-and-recover/</guid>
      <description>作为一个 gophper，我相信你对于 panic 和 recover 肯定不陌生，但是你有没有想过。当我们执行了这两条语句之后。底层到底发生了什么事呢？前几天和同事刚好聊到相关的话题，发现其实大家对这块理解还是比较模糊的。希望这篇文章能够从更深入的角度告诉你为什么，它到底做了什么事？
思考 一、为什么会中止运行 func main() { panic(&amp;#34;EDDYCJY.&amp;#34;) } 输出结果：
$ go run main.go panic: EDDYCJY. goroutine 1 [running]: main.main() /Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:4 +0x39 exit status 2 请思考一下，为什么执行 panic 后会导致应用程序运行中止？（而不是单单说执行了 panic 所以就结束了这么含糊）</description>
    </item>
    
    <item>
      <title>为什么遍历 Go map 是无序的</title>
      <link>https://wangtu2022.github.io/posts/go/map/2019-04-07-why-map-no-order/</link>
      <pubDate>Sun, 07 Apr 2019 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/map/2019-04-07-why-map-no-order/</guid>
      <description>有的小伙伴没留意过 Go map 输出顺序，以为它是稳定的有序的；有的小伙伴知道是无序的，但却不知道为什么？有的却理解错误？今天我们将通过本文，揭开 for range map 的 “神秘” 面纱，看看它内部实现到底是怎么样的，输出顺序到底是怎么样？
前言 func main() { m := make(map[int32]string) m[0] = &amp;#34;EDDYCJY1&amp;#34; m[1] = &amp;#34;EDDYCJY2&amp;#34; m[2] = &amp;#34;EDDYCJY3&amp;#34; m[3] = &amp;#34;EDDYCJY4&amp;#34; m[4] = &amp;#34;EDDYCJY5&amp;#34; for k, v := range m { log.</description>
    </item>
    
    <item>
      <title>深入理解 Go map：赋值和扩容迁移</title>
      <link>https://wangtu2022.github.io/posts/go/map/2019-03-24-map-assign/</link>
      <pubDate>Sun, 24 Mar 2019 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/map/2019-03-24-map-assign/</guid>
      <description>概要 在 上一章节 中，数据结构小节里讲解了大量基础字段，可能你会疑惑需要 #&amp;amp;（！……#（！￥！ 来干嘛？接下来我们一起简单了解一下基础概念。再开始研讨今天文章的重点内容。我相信这样你能更好的读懂这篇文章
哈希函数 哈希函数，又称散列算法、散列函数。主要作用是通过特定算法将数据根据一定规则组合重新生成得到一个散列值
而在哈希表中，其生成的散列值常用于寻找其键映射到哪一个桶上。而一个好的哈希函数，应当尽量少的出现哈希冲突，以此保证操作哈希表的时间复杂度（但是哈希冲突在目前来讲，是无法避免的。我们需要 “解决” 它）
链地址法 在哈希操作中，相当核心的一个处理动作就是 “哈希冲突” 的解决。而在 Go map 中采用的就是 &amp;ldquo;链地址法 &amp;quot; 去解决哈希冲突，又称 &amp;ldquo;拉链法&amp;rdquo;。其主要做法是数组 + 链表的数据结构，其溢出节点的存储内存都是动态申请的，因此相对更灵活。而每一个元素都是一个链表。如下图：
桶/溢出桶 type hmap struct { ... buckets unsafe.</description>
    </item>
    
    <item>
      <title>深入理解 Go map：初始化和访问元素</title>
      <link>https://wangtu2022.github.io/posts/go/map/2019-03-05-map-access/</link>
      <pubDate>Tue, 05 Mar 2019 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/map/2019-03-05-map-access/</guid>
      <description>从本文开始咱们一起探索 Go map 里面的奥妙吧，看看它的内在是怎么构成的，又分别有什么值得留意的地方？
第一篇将探讨初始化和访问元素相关板块，咱们带着疑问去学习，例如：
初始化的时候会马上分配内存吗？ 底层数据是如何存储的？ 底层是如何使用 key 去寻找数据的？ 底层是用什么方式解决哈希冲突的？ 数据类型那么多，底层又是怎么处理的呢？ &amp;hellip;
数据结构 首先我们一起看看 Go map 的基础数据结构，先有一个大致的印象
hmap type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.</description>
    </item>
    
    <item>
      <title>Go Slice 最大容量大小是怎么来的</title>
      <link>https://wangtu2022.github.io/posts/go/slice/2019-01-06-why-slice-max/</link>
      <pubDate>Sun, 06 Jan 2019 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/slice/2019-01-06-why-slice-max/</guid>
      <description>前言 在《深入理解 Go Slice》中，我们提到了 “根据其类型大小去获取能够申请的最大容量大小” 的处理逻辑。今天我们将更深入地去探究一下，底层到底做了什么东西，涉及什么知识点？
Go Slice 对应代码如下：
func makeslice(et *_type, len, cap int) slice { maxElements := maxSliceCap(et.size) if len &amp;lt; 0 || uintptr(len) &amp;gt; maxElements { .</description>
    </item>
    
    <item>
      <title>有点不安全却又一亮的 Go unsafe.Pointer</title>
      <link>https://wangtu2022.github.io/posts/go/pkg/2018-12-15-unsafe/</link>
      <pubDate>Sat, 15 Dec 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/pkg/2018-12-15-unsafe/</guid>
      <description>在上一篇文章《深入理解 Go Slice》中，大家会发现其底层数据结构使用了 unsafe.Pointer。因此想着再介绍一下其关联知识
前言 在大家学习 Go 的时候，肯定都学过 “Go 的指针是不支持指针运算和转换” 这个知识点。为什么呢？
首先，Go 是一门静态语言，所有的变量都必须为标量类型。不同的类型不能够进行赋值、计算等跨类型的操作。那么指针也对应着相对的类型，也在 Compile 的静态类型检查的范围内。同时静态语言，也称为强类型。也就是一旦定义了，就不能再改变它
错误示例 func main(){ num := 5 numPointer := &amp;amp;num flnum := (*float32)(numPointer) fmt.Println(flnum) } 输出结果：</description>
    </item>
    
    <item>
      <title>深入理解 Go Slice</title>
      <link>https://wangtu2022.github.io/posts/go/slice/2018-12-11-slice/</link>
      <pubDate>Tue, 11 Dec 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/slice/2018-12-11-slice/</guid>
      <description>是什么 在 Go 中，Slice（切片）是抽象在 Array（数组）之上的特殊类型。为了更好地了解 Slice，第一步需要先对 Array 进行理解。深刻了解 Slice 与 Array 之间的区别后，就能更好的对其底层一番摸索 😄
用法 Array func main() { nums := [3]int{} nums[0] = 1 n := nums[0] n = 2 fmt.</description>
    </item>
    
    <item>
      <title>fmt 标准库 --- Print* 是怎么样输出的？</title>
      <link>https://wangtu2022.github.io/posts/go/pkg/2018-12-04-fmt/</link>
      <pubDate>Tue, 04 Dec 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/pkg/2018-12-04-fmt/</guid>
      <description>前言 package main import ( &amp;#34;fmt&amp;#34; ) func main() { fmt.Println(&amp;#34;Hello World!&amp;#34;) } 标准开场见多了，那内部标准库又是怎么输出这段英文的呢？今天一起来围观下源码吧 🤭
原型 func Print(a ...interface{}) (n int, err error) { return Fprint(os.Stdout, a...) } func Println(a .</description>
    </item>
    
    <item>
      <title>log 标准库</title>
      <link>https://wangtu2022.github.io/posts/go/pkg/2018-09-28-log/</link>
      <pubDate>Fri, 28 Sep 2018 12:00:00 +0000</pubDate>
      
      <guid>https://wangtu2022.github.io/posts/go/pkg/2018-09-28-log/</guid>
      <description>日志 输出 2018/09/28 20:03:08 EDDYCJY Blog... 构成 [日期]&amp;lt;空格&amp;gt;[时分秒]&amp;lt;空格&amp;gt;[内容]&amp;lt;\n&amp;gt;
源码剖析 Logger type Logger struct { mu sync.Mutex prefix string flag int out io.Writer buf []byte } mu：互斥锁，用于确保原子的写入 prefix：每行需写入的日志前缀内容 flag：设置日志辅助信息（时间、文件名、行号）的写入。可选如下标识位： const ( Ldate = 1 &amp;lt;&amp;lt; iota // value: 1 Ltime // value: 2 Lmicroseconds // value: 4 Llongfile // value: 8 Lshortfile // value: 16 LUTC // value: 32 LstdFlags = Ldate | Ltime // value: 3 ) Ldate：当地时区的格式化日期：2009/01/23 Ltime：当地时区的格式化时间：01:23:23 Lmicroseconds：在 Ltime 的基础上，增加微秒的时间数值显示 Llongfile：完整的文件名和行号：/a/b/c/d.</description>
    </item>
    
  </channel>
</rss>
